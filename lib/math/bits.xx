// Copyright 2022 The X Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

const uvnan   :u64 = 0x7FF8000000000001
const uvinf   :u64 = 0x7FF0000000000000
const uvneginf:u64 = 0xFFF0000000000000

//doc: Returns an IEEE 754 “not-a-number” value.
@inline
pub nan() f64 { ret f64_from_bits(uvnan) }

//doc: Reports whether f is an IEEE 754 “not-a-number” value.
@inline
pub isnan(const f f64) bool {
	// IEEE 754 says that only NaNs satisfy f != f.
	// To avoid the floating-point hardware, could use:
	//	x: = f64_bits(f);
	//	ret u32(x>>shift)&mask == mask && x != uvinf && x != uvneginf
	ret f != f
}

//doc: Returns positive infinity if sign, negative infinity if !sign.
pub inf(const sign bool) f64 {
	if sign {
		ret f64_from_bits(uvinf)
	}
	ret f64_from_bits(uvneginf)
}

//doc:
// Reports whether f is an infinity, according to sign.
// If sign > 0, IsInf reports whether f is positive infinity.
// If sign < 0, IsInf reports whether f is negative infinity.
// If sign == 0, IsInf reports whether f is either infinity.
@inline
pub isinf(const f f64, const sign{0} int) bool {
	// Test for infinity by comparing against maximum float.
	// To avoid the floating-point hardware, could use:
	//	x: = f64_bits(f);
	//	ret sign >= 0 && x == uvinf || sign <= 0 && x == uvneginf;
	ret sign >= 0 && f > f64.max || sign <= 0 && f < -f64.max
}
