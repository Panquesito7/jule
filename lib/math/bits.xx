// Copyright 2022 The X Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

const uvnan   :u64 = 0x7FF8000000000001
const uvinf   :u64 = 0x7FF0000000000000
const uvneginf:u64 = 0xFFF0000000000000
const mask    :u64 = 0x7FF
const shift   :u64 = u64(64 - 11 - 1)
const bias    :u64 = 1023

//doc: Returns an IEEE 754 “not-a-number” value.
@inline
pub nan() f64 { ret f64_from_bits(uvnan) }

//doc: Reports whether f is an IEEE 754 “not-a-number” value.
@inline
pub isnan(const f f64) bool {
	// IEEE 754 says that only NaNs satisfy f != f.
	// To avoid the floating-point hardware, could use:
	//	x: = f64_bits(f);
	//	ret u32(x>>shift)&mask == mask && x != uvinf && x != uvneginf
	ret f != f
}

//doc: Returns positive infinity if sign >= 0, negative infinity if !sign < 0.
pub inf(const sign int) f64 {
	if sign >= 0 {
		ret f64_from_bits(uvinf)
	}
	ret f64_from_bits(uvneginf)
}

//doc:
// Reports whether f is an infinity, according to sign.
// If sign > 0, isinf reports whether f is positive infinity.
// If sign < 0, isinf reports whether f is negative infinity.
// If sign == 0, isinf reports whether f is either infinity.
@inline
pub isinf(const f f64, const sign int) bool {
	// Test for infinity by comparing against maximum float.
	// To avoid the floating-point hardware, could use:
	//	x: = f64_bits(f);
	//	ret sign >= 0 && x == uvinf || sign <= 0 && x == uvneginf;
	ret sign >= 0 && f > f64.max || sign <= 0 && f < -f64.max
}

//doc:
// Returns a normal number y and exponent exp
// satisfying x == y × 2**exp. It assumes x is finite and non-zero.
normalize(const x f64) [y f64, exp int] {
	const smallest_normal: = 2.2250738585072014e-308 // 2**-1022
	if abs(x) < smallest_normal {
		ret x * (1 << 52), -52
	}
	ret x, 0
}
