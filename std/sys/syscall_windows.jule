// Copyright 2022 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::unicode::utf16::{append_rune}

use cpp "<sys/stat.h>"
use cpp "sys.hpp"

cpp type wchar_t: u16
cpp struct stat{}
cpp fn GetStdHandle(stdh: uintptr) *unsafe
cpp fn CloseHandle(stdh: *unsafe) bool
cpp fn wstat(path: *cpp.wchar_t, handle: *cpp.stat) (err: int)

pub type handle: uintptr

pub const INVALID_HANDLE = ^handle(0)

pub let STDIN  = get_std_handle(uintptr(STD_INPUT_HANDLE))
pub let STDOUT = get_std_handle(uintptr(STD_OUTPUT_HANDLE))
pub let STDERR = get_std_handle(uintptr(STD_ERROR_HANDLE))

// Returns the UTF-16 encoding of the UTF-8 string
// s, with a terminating NUL added. If s contains a NUL byte at any
// location, it returns (nil, false).
pub fn utf16_from_str(s: str) ([]u16, bool) {
	// In the worst case all characters require two u16.
	// Also account for the terminating NULL character.
	// See: C Strings and Windows UTF16.

	let mut buf: []u16 = nil
	let runes = ([]rune)(s)
	for _, r in runes {
		buf = append_rune(buf, r)
	}
	ret append_rune(buf, '\x00'), true
}

pub fn get_std_handle(stdh: uintptr) handle { ret handle(cpp.GetStdHandle(stdh)) }
pub fn close_handle(stdh: handle) bool { ret cpp.CloseHandle(unsafe{ (*unsafe)(stdh) }) }

pub fn stat(path: str, handle: *cpp.stat) bool {
	let (utf16_path, ok) = utf16_from_str(path)
	if !ok {
		ret false
	}
	ret cpp.wstat(unsafe{ (*cpp.wchar_t)(&utf16_path[0]) }, handle) == 0
}
