// Copyright 2022 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

cpp use "<dirent.h>"
cpp use "<fcntl.h>"
cpp use "<unistd.h>"

cpp use "syscall_unix.hpp"

cpp type char: i8

//jule:typedef
cpp struct DIR{}

cpp struct dirent {
    pub d_name: *cpp.char
}

// This function actually equals to stat,
// just interface to ignore identifier already exist error of compiler.
cpp unsafe fn __jule_stat(path: *cpp.char, mut handle: *cpp.stat): int

cpp unsafe fn __jule_str_from_byte_ptr(s: *byte): str
cpp unsafe fn opendir(path: *cpp.char): *cpp.DIR
cpp unsafe fn closedir(mut dir: *cpp.DIR): int
cpp unsafe fn readdir(mut dir: *cpp.DIR): *cpp.dirent
cpp unsafe fn open(path: *cpp.char, flag: int, mode: int): int
cpp unsafe fn getcwd(buff: *cpp.char, bufflen: uint): *cpp.char
cpp unsafe fn chdir(path: *cpp.char): int
cpp unsafe fn remove(path: *cpp.char): int
cpp unsafe fn mkdir(path: *cpp.char, mode: int): int
cpp unsafe fn rmdir(path: *cpp.char): int
cpp unsafe fn unlink(path: *cpp.char): int

// C's DIR.
pub type Dir: cpp.DIR

// C's dirent.
pub type Dirent: cpp.dirent

pub static STDIN: uintptr  = 0
pub static STDOUT: uintptr = 1
pub static STDERR: uintptr = 2

// Returns the string of s, with a terminating NULL removed.
// Returns empty string if pointer is nil.
pub unsafe fn byte_ptr_to_str(s: *byte): str {
    if s == nil {
        ret ""
    }
    ret cpp.__jule_str_from_byte_ptr(s)
}

// Calls C's stat function.
pub unsafe fn stat(path: *byte, mut stat: *Stat): int {
    ret cpp.__jule_stat((*cpp.char)(path), stat)
}

// Wrapper for C's open function.
pub unsafe fn open(path: *byte, flag: int, mode: int): int {
    ret cpp.open((*cpp.char)(path), flag, mode)
}

// Reads current working directory into buff.
// Returns pointer to buff if success, nil pointer if error occurs.
pub unsafe fn getcwd(buff: *byte, bufflen: uint): *byte {
    ret (*byte)(cpp.getcwd((*cpp.char)(buff), bufflen))
}

// Calls C's opendir function.
pub unsafe fn opendir(path: *byte): *Dir { ret cpp.opendir((*cpp.char)(path)) }

// Calls C's readdir function.
pub unsafe fn readdir(mut dir: *Dir): *Dirent { ret cpp.readdir(dir) }

// Calls C's closedir function.
pub unsafe fn closedir(mut dir: *Dir): int { ret cpp.closedir(dir) }

// Calls C's chdir function.
pub unsafe fn chdir(path: *byte): int { ret cpp.chdir((*cpp.char)(path)) }

// Wrapper for C's remove function.
pub unsafe fn remove(path: *byte): int { ret cpp.remove((*cpp.char)(path)) }

// Wrapper for C's mkdir function.
pub unsafe fn mkdir(path: *byte, mode: int): int {
    ret cpp.mkdir((*cpp.char)(path), mode)
}

// Wrapper for C's rmdir function.
pub unsafe fn rmdir(path: *byte): int { ret cpp.rmdir((*cpp.char)(path)) }

// Wrapper for C's unlink function.
pub unsafe fn unlink(path: *byte): int { ret cpp.unlink((*cpp.char)(path)) }
