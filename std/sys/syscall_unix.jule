// Copyright 2022 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use cpp "<dirent.h>"

//jule:typedef
cpp struct DIR{}

cpp struct dirent {
	pub d_name: str
}

// This function actually equals to stat,
// just interface to ignore identifier already exist error of compiler.
cpp unsafe fn __julec_stat(path: str, handle: *cpp.stat): (err: int)
cpp fn opendir(path: str): *cpp.DIR
cpp unsafe fn closedir(mut dir: *cpp.DIR): int
cpp unsafe fn readdir(mut dir: *cpp.DIR): *cpp.dirent
cpp fn fopen(path: str, mode: str): *cpp.FILE
cpp fn open(path: str, flag: int, mode: int): int

pub let STDIN  = uintptr(0)
pub let STDOUT = uintptr(1)
pub let STDERR = uintptr(2)

// Wrapper for C's DIR.
pub struct Dir {
	handle: *cpp.DIR
}

impl Dir {
	// Returns handle as uintptr.
	pub fn addr(self): uintptr {
		ret uintptr(self.handle)
	}

	// Calls C's closedir function with handle.
	// Returns 0 if handle is nil.
	pub fn close(mut self): int {
		if self.addr() == 0 {
			ret 0
		}
		ret unsafe { cpp.closedir(self.handle) }
	}

	// Calls C's readdir function with handle and returns Dirent.
	// Returns nil reference if handle is nil or readdir returns nil.
	pub fn read(mut self): (dirent: &Dirent) {
		if self.addr() != 0 {
			let mut handle = unsafe { cpp.readdir(self.handle) }
			if handle != nil {
				dirent = &Dirent{handle: handle}
			}
		}
		ret
	}
}

// Wrapper for C's dirent.
pub struct Dirent {
	handle: *cpp.dirent
}

impl Dirent {
	// Returns handle as uintptr.
	pub fn addr(self): uintptr {
		ret uintptr(self.handle)
	}

	// Returns d_name field of handle as string.
	// Returns empty string if handle is nil.
	pub fn d_name(self): str {
		if self.addr() == 0 {
			ret ""
		}
		ret unsafe { self.handle.d_name }
	}
}

// Calls C's stat function.
// Returns nil reference if error occurs.
pub fn stat(path: str): (stat: &Stat) {
	let mut handle = cpp.stat{}
	if (unsafe { cpp.__julec_stat(path, &handle) } == 0) {
		stat = &Stat{
			st_mode: handle.st_mode,
			st_size: handle.st_size,
		}
	}
	ret
}

// Calls C's opendir function.
// Returns nil reference if error occurs.
pub fn open_dir(path: str): &Dir {
	let mut handle = cpp.opendir(path)
	if handle == nil {
		ret new(Dir)
	}
	ret &Dir{handle: handle}
}

// Calls C's fopen function.
// Returns nil reference if error occurs.
// or C's fopen function returns nil pointer.
pub fn fopen(path: str, mode: str): &File {
	let handle = cpp.fopen(path, mode)
	if handle == nil {
		ret new(File)
	}
	ret &File{handle: handle}
}

// Wrapper for C's open function.
pub fn open(path: str, flag: int, mode: int): int {
	ret cpp.open(path, flag, mode)
}
