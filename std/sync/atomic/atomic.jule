// Copyright 2022 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use cpp "atomic.hpp"

//jule:cdef
cpp fn __julec_atomic_swap_i32(addr: *i32, new: i32) (old: i32)

//jule:cdef
cpp fn __julec_atomic_swap_i64(addr: *i64, new: i64) (old: i64)

//jule:cdef
cpp fn __julec_atomic_swap_u32(addr: *u32, new: u32) (old: u32)

//jule:cdef
cpp fn __julec_atomic_swap_u64(addr: *u64, new: u64) (old: u64)

//jule:cdef
cpp fn __julec_atomic_swap_uintptr(addr: *uintptr, new: uintptr) (old: uintptr)

//jule:cdef
cpp fn __julec_atomic_compare_swap_i32(addr: *i32, old: i32, new: i32) (swapped: bool)

//jule:cdef
cpp fn __julec_atomic_compare_swap_i64(addr: *i64, old: i64, new: i64) (swapped: bool)

//jule:cdef
cpp fn __julec_atomic_compare_swap_u32(addr: *u32, old: u32, new: u32) (swapped: bool)

//jule:cdef
cpp fn __julec_atomic_compare_swap_u64(addr: *u64, old: u64, new: u64) (swapped: bool)

//jule:cdef
cpp fn __julec_atomic_compare_swap_uintptr(addr: *uintptr, old: uintptr, new: uintptr) (swapped: bool)

//jule:cdef
cpp fn __julec_atomic_add_i32(addr: *i32, delta: i32) (old: i32)

//jule:cdef
cpp fn __julec_atomic_add_i64(addr: *i64, delta: i64) (old: i64)

//jule:cdef
cpp fn __julec_atomic_add_u32(addr: *u32, delta: u32) (old: u32)

//jule:cdef
cpp fn __julec_atomic_add_u64(addr: *u64, delta: u64) (old: u64)

//jule:cdef
cpp fn __julec_atomic_add_uintptr(addr: *uintptr, delta: uintptr) (old: uintptr)

//jule:cdef
cpp fn __julec_atomic_load_i32(addr: *i32) i32

//jule:cdef
cpp fn __julec_atomic_load_i64(addr: *i64) i64

//jule:cdef
cpp fn __julec_atomic_load_u32(addr: *u32) u32

//jule:cdef
cpp fn __julec_atomic_load_u64(addr: *u64) u64

//jule:cdef
cpp fn __julec_atomic_load_uintptr(addr: *uintptr) uintptr

//jule:cdef
cpp fn __julec_atomic_store_i32(addr: *i32, val: i32)

//jule:cdef
cpp fn __julec_atomic_store_i64(addr: *i64, val: i64)

//jule:cdef
cpp fn __julec_atomic_store_u32(addr: *u32, val: u32)

//jule:cdef
cpp fn __julec_atomic_store_u64(addr: *u64, val: u64)

//jule:cdef
cpp fn __julec_atomic_store_uintptr(addr: *uintptr, val: uintptr)

const invalid_ptr_error = "invalid memory address or nil pointer deference for atomic operation"

// Atomically stores new into *addr and returns the previous *addr value.
pub fn swap_i32(addr: *i32, new: i32) (old: i32) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_swap_i32(addr, new)
}

// Atomically stores new into *addr and returns the previous *addr value.
pub fn swap_i64(addr: *i64, new: i64) (old: i64) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_swap_i64(addr, new)
}

// Atomically stores new into *addr and returns the previous *addr value.
pub fn swap_u32(addr: *u32, new: u32) (old: u32) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_swap_u32(addr, new)
}

// Atomically stores new into *addr and returns the previous *addr value.
pub fn swap_u64(addr: *u64, new: u64) (old: u64) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_swap_u64(addr, new)
}

// Atomically stores new into *addr and returns the previous *addr value.
pub fn swap_uinptr(addr: *uintptr, new: uintptr) (old: uintptr) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_swap_uintptr(addr, new)
}

// Executes the compare-and-swap operation for an i32 value.
pub fn compare_swap_i32(addr: *i32, old: i32, new: i32) (swapped: bool) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_compare_swap_i32(addr, old, new)
}

// Executes the compare-and-swap operation for an i64 value.
pub fn compare_swap_i64(addr: *i64, old: i64, new: i64) (swapped: bool) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_compare_swap_i64(addr, old, new)
}

// Executes the compare-and-swap operation for an u32 value.
pub fn compare_swap_u32(addr: *u32, old: u32, new: u32) (swapped: bool) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_compare_swap_u32(addr, old, new)
}

// Executes the compare-and-swap operation for an u64 value.
pub fn compare_swap_u64(addr: *u64, old: u64, new: u64) (swapped: bool) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_compare_swap_u64(addr, old, new)
}

// Executes the compare-and-swap operation for an uintptr value.
pub fn compare_swap_uintptr(addr: *uintptr, old: uintptr, new: uintptr) (swapped: bool) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_compare_swap_uintptr(addr, old, new)
}

// Atomically adds delta to *addr and returns the previous *addr value.
pub fn add_i32(addr: *i32, delta: i32) (old: i32) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_add_i32(addr, delta)
}

// Atomically adds delta to *addr and returns the previous *addr value.
pub fn add_i64(addr: *i64, delta: i64) (old: i64) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_add_i64(addr, delta)
}

// Atomically adds delta to *addr and returns the previous *addr value.
pub fn add_u32(addr: *u32, delta: u32) (old: u32) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_add_u32(addr, delta)
}

// Atomically adds delta to *addr and returns the previous *addr value.
pub fn add_u64(addr: *u64, delta: u64) (old: u64) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_add_u64(addr, delta)
}

// Atomically adds delta to *addr and returns the previous *addr value.
pub fn add_uinptr(addr: *uintptr, delta: uintptr) (old: uintptr) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_add_uintptr(addr, delta)
}

// Atomically loads *addr.
pub fn load_i32(addr: *i32) i32 {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_load_i32(addr)
}

// Atomically loads *addr.
pub fn load_i64(addr: *i64) i64 {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_load_i64(addr)
}

// Atomically loads *addr.
pub fn load_u32(addr: *u32) u32 {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_load_u32(addr)
}

// Atomically loads *addr.
pub fn load_u64(addr: *u64) u64 {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_load_u64(addr)
}

// Atomically loads *addr.
pub fn load_uinptr(addr: *uintptr) uintptr {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	ret cpp.__julec_atomic_load_uintptr(addr)
}

// Atomically stores val into *addr.
pub fn store_i32(addr: *i32, val: i32) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	cpp.__julec_atomic_store_i32(addr, val)
}

// Atomically stores val into *addr.
pub fn store_i64(addr: *i64, val: i64) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	cpp.__julec_atomic_store_i64(addr, val)
}

// Atomically stores val into *addr.
pub fn store_u32(addr: *u32, val: u32) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	cpp.__julec_atomic_store_u32(addr, val)
}

// Atomically stores val into *addr.
pub fn store_u64(addr: *u64, val: u64) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	cpp.__julec_atomic_store_u64(addr, val)
}

// Atomically stores val into *addr.
pub fn store_uinptr(addr: *uintptr, val: uintptr) {
	if addr == nil {
		panic(invalid_ptr_error)
	}
	cpp.__julec_atomic_store_uintptr(addr, val)
}
