// Copyright 2022 The X Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Package utf8 implements functions and constants to support text encoded in
// UTF-8. It includes functions to translate between runes and UTF-8 byte sequences.
// See https://en.wikipedia.org/wiki/UTF-8

// The conditions RUNE_ERROR==std::unicode::REPLACEMENT_CHAR and
// MAX_RUNE==std::unicode::MAX_RUNE are verified in the tests.
// Defining them locally avoids this package depending on package std::unicode.

// Numbers fundamental to the encoding.

//doc: The "error" rune or "Unicode replacement character"
pub const RUNE_ERROR: = '\uFFFD'

//doc: Characters below RUNE_SELF are represented as themselves in a single byte.
pub const RUNE_SELF: = 0x80

//doc: Maximum valid Unicode code point.
pub const MAX_RUNE: = '\U0010FFFF'

//doc: Maximum number of bytes of a UTF-8 encoded Unicode character.
pub const UTF_MAX: = 4

// Code points in the surrogate range are not valid for UTF-8.
const SURROGATE_MIN: = 0xD800
const SURROGATE_MAX: = 0xDFFF

const T1: = 0b00000000
const TX: = 0b10000000
const T2: = 0b11000000
const T3: = 0b11100000
const T4: = 0b11110000
const T5: = 0b11111000

const MASKX: = 0b00111111
const MASK2: = 0b00011111
const MASK3: = 0b00001111
const MASK4: = 0b00000111

const RUNE1_MAX: = 1<<7 - 1
const RUNE2_MAX: = 1<<11 - 1
const RUNE3_MAX: = 1<<16 - 1

// The default lowest and highest continuation byte.
const LOCB: = 0b10000000
const HICB: = 0b10111111

// These names of these constants are chosen to give nice alignment in the
// table below. The first nibble is an index into accept_ranges or F for
// special one-byte cases. The second nibble is the Rune length or the
// Status for the special one-byte case.
const XX: = 0xF1 // invalid: size 1
const AS: = 0xF0 // ASCII: size 1
const S1: = 0x02 // accept 0, size 2
const S2: = 0x13 // accept 1, size 3
const S3: = 0x03 // accept 0, size 3
const S4: = 0x23 // accept 2, size 3
const S5: = 0x34 // accept 3, size 4
const S6: = 0x04 // accept 0, size 4
const S7: = 0x44 // accept 4, size 4

// Is information about the first byte in a UTF-8 sequence.
first: = [256]byte{
	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, // 0x00-0x0F
	AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, // 0x10-0x1F
	AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, // 0x20-0x2F
	AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, // 0x30-0x3F
	AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, // 0x40-0x4F
	AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, // 0x50-0x5F
	AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, // 0x60-0x6F
	AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, AS, // 0x70-0x7F
	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, // 0x80-0x8F
	XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, // 0x90-0x9F
	XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, // 0xA0-0xAF
	XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, // 0xB0-0xBF
	XX, XX, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, // 0xC0-0xCF
	S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, S1, // 0xD0-0xDF
	S2, S3, S3, S3, S3, S3, S3, S3, S3, S3, S3, S3, S3, S4, S3, S3, // 0xE0-0xEF
	S5, S6, S6, S6, S7, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, XX, // 0xF0-0xFF
}

// Gives the range of valid values for the second byte in a UTF-8 sequence.
struct accept_range {
	lo: byte // lowest value for second byte.
	hi: byte // highest value for second byte.
}

// Has size 16 to avoid bounds checks in the code that uses it.
accept_ranges: = [16]accept_range{
	accept_range{LOCB, HICB},
	accept_range{0xA0, HICB},
	accept_range{LOCB, 0x9F},
	accept_range{0x90, HICB},
	accept_range{LOCB, 0x8F},
}

//doc:
// Reports whether the bytes in p begin with a full UTF-8 encoding of a rune.
// An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
pub full_rune(p []byte) bool {
	if p.len == 0 {
		ret false
	}
	x: = first[p[0]]
	if p.len >= int(x&7) {
		ret true // ASCII, invalid or valid.
	}
	// Must be short or invalid.
	accept: = accept_ranges[x>>4]
	if p.len > 1 && (p[1] < accept.lo || accept.hi < p[1]) {
		ret true
	} else if p.len > 2 && (p[2] < LOCB || HICB < p[2]) {
		ret true
	}
	ret false
}

//doc:
// Reports whether r can be legally encoded as UTF-8.
// Code points that are out of range or a surrogate half are illegal.
pub valid_rune(r rune) bool {
	match {
	case 0 <= r && r < SURROGATE_MIN:
		ret true
	case SURROGATE_MAX < r && r <= MAX_RUNE:
		ret true
	}
	ret false
}
