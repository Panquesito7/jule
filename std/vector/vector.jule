// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::mem::{size_of}

use cpp "alloc.hpp"

cpp fn __jule_std_vector_alloc[T](n: int): *unsafe
cpp unsafe fn __jule_std_vector_dealloc[T](heap: *unsafe)
cpp unsafe fn __jule_std_vector_deref[T](heap: *unsafe, i: int): T
cpp unsafe fn __jule_std_vector_heap_assign[T](heap: *unsafe, i: int, item: T)
cpp unsafe fn __jule_std_vector_heap_move[T](heap: *unsafe, i: int, dest: int)
cpp unsafe fn __jule_std_vector_copy_range[T](dest: *unsafe, buff: *unsafe, len: int)
cpp unsafe fn __jule_get_pointer_of_slice[T](slc: []T): *unsafe

//jule:typedef
cpp struct StdJuleVectorBuffer[T] {
	len:  int
	cap:  int
	heap: *unsafe
	drop: fn()
}

const GROW_FACTOR = 2

// Wrapper for dynamic array.
// Uses capacity for performance.
// Grows capacity if necessary.
// But always allocates more for future pushes.
// The elements are stored contiguously.
//
// Deallocates itself when destroyed.
//
// Vectors aren't use shared allocation between them.
// Allocates new space and copies (not deep copy) items into space.
pub struct Vector[T] {
	_buffer: cpp.StdJuleVectorBuffer[T]
}

impl Vector {
	fn calc_grow(self, delta: int): int {
		let t = self._buffer.len + delta
		ret t*GROW_FACTOR
	}

	fn resize_alloc(mut self, n: int) {
		let mut new_heap = cpp.__jule_std_vector_alloc[T](n)
		if new_heap == nil {
			panic("Vector[T].resize_alloc: heap reallocation failed")
		}

		if self._buffer.heap == nil {
			self._buffer.heap = new_heap
			self._buffer.cap = n
			ret
		}

		unsafe {
			if self._buffer.len > 0 {
				cpp.__jule_std_vector_copy_range[T](
					new_heap,
					self._buffer.heap,
					self._buffer.len)
			}
			cpp.__jule_std_vector_dealloc[T](self._buffer.heap)
			self._buffer.heap = new_heap
		}
		self._buffer.cap = n
	}

	fn review_allocation(mut self, delta: int) {
		if self._buffer.len+delta > self._buffer.cap {
			self.resize_alloc(self.calc_grow(delta))
		}
	}

	// Returns length.
	pub fn len(self): int { ret self._buffer.len }

	// Returns capacity.
	pub fn cap(self): int { ret self._buffer.cap }

	// Deallocates heap.
	pub fn dealloc(mut self) {
		self._buffer.drop()
	}

	// Sets length.
	// Sets length to zero if n < 0.
	// Don't set length if n >= length of vector.
	pub fn set_len(mut self, n: int) {
		if n < 0 {
			self._buffer.len = 0
			ret
		}
		if n >= self._buffer.len {
			ret
		}
		self._buffer.len = n
	}

	// Returns item by index.
	pub fn at(mut self, i: int): T {
		if i < 0 || i >= self._buffer.len {
			panic("Vector[T].at: out of range")
		}
		ret unsafe { cpp.__jule_std_vector_deref[T](self._buffer.heap, i) }
	}

	// Set element by index.
	pub fn set(mut self, i: int, mut item: T) {
		if i < 0 || i >= self._buffer.len {
			panic("Vector[T].set: out of range")
		}
		unsafe { cpp.__jule_std_vector_heap_assign[T](self._buffer.heap, i, item) }
	}

	// Push item to end of heap.
	pub fn push(mut self, mut item: T) {
		if self._buffer.len >= self._buffer.cap {
			self.resize_alloc((self._buffer.cap*GROW_FACTOR)+1)
		}

		unsafe {
			cpp.__jule_std_vector_heap_assign[T](
				self._buffer.heap,
				self._buffer.len,
				item)
		}
		self._buffer.len++
	}

	// Push item to front of heap.
	pub fn push_front(mut self, mut item: T) {
		if self._buffer.len >= self._buffer.cap {
			self.resize_alloc((self._buffer.cap*GROW_FACTOR)+1)
		}

		// Shift items.
		let mut i = self._buffer.len-1
		for i >= 0; i-- {
			unsafe { cpp.__jule_std_vector_heap_move[T](self._buffer.heap, i, i+1) }
		}

		// Assign.
		unsafe { cpp.__jule_std_vector_heap_assign[T](self._buffer.heap, 0, item) }
		self._buffer.len++
	}

	// Push items to end of heap.
	pub fn append(mut self, mut items: ...T) {
		if items.len == 0 {
			ret
		}

		self.review_allocation(items.len)

		unsafe {
			cpp.__jule_std_vector_copy_range[T](
				(*unsafe)(uintptr(self._buffer.heap)+(size_of(T)*self._buffer.len)),
				cpp.__jule_get_pointer_of_slice[T](items),
				items.len)
		}
		self._buffer.len += items.len
	}

	// Merge items to end of heap.
	pub fn merge(mut self, mut vec: Vector[T]) {
		if vec._buffer.len == 0 {
			ret
		}

		self.review_allocation(vec._buffer.len)

		unsafe {
			cpp.__jule_std_vector_copy_range[T](
				(*unsafe)(uintptr(self._buffer.heap)+(size_of(T)*self._buffer.len)),
				vec._buffer.heap,
				vec._buffer.len)
		}
		self._buffer.len += vec._buffer.len
	}

	// Merge items to front of heap.
	pub fn merge_front(mut self, mut vec: Vector[T]) {
		if vec._buffer.len == 0 {
			ret
		}

		self.review_allocation(vec._buffer.len)

		// Shift items.
		let mut i = self._buffer.len-1
		for i >= 0; i-- {
			unsafe {
				cpp.__jule_std_vector_heap_move[T](
					self._buffer.heap, i, i+vec._buffer.len)
			}
		}

		unsafe {
			cpp.__jule_std_vector_copy_range[T](
				self._buffer.heap,
				vec._buffer.heap,
				vec._buffer.len)
		}
		self._buffer.len += vec._buffer.len
	}

	// Remove range from heap.
	pub fn remove_range(mut self, start: int, d: int) {
		if n < 1 {
			ret
		}

		if start < -1 {
			panic("Vector[T].remove_range: removing starts at negative index")
		}
		if start >= self._buffer.len {
			panic("Vector[T].remove_range: removing starts at out of range")
		}
		if self._buffer.len-start-n < 0 {
			panic("Vector[T].remove_range: removing continues at out of range ")
		}

		// Shift items.
		let mut i = start + n
		for i < self._buffer.len; i++ {
			unsafe { cpp.__jule_std_vector_heap_move[T](self._buffer.heap, i, i-n) }
		}

		self._buffer.len -= n
	}
}

// Allocate new vector.
pub fn new_vector[T](cap: int): Vector[T] {
	let mut vec = Vector[T]{}
	if cap != 0 {
		vec.resize_alloc(cap)
	}
	ret vec
}
