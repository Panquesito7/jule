#pragma enofi
// X test codes

// cxx:#define TEST_CXX_EMBED

type TEST_TYPEDEF i32

//doc:Test for global variable.
TEST_GLOBAL: = 10;
//doc: Test for global constant variable.
const TEST_CONST: = 20
volatile const TEST_VOLATILE_CONST: = false
volatile TEST_VOLATILE: = 5

@inline
// doc: Test for inline function.
test_inline_function() { }

test_string_concat() {
  "Hello" + " " + "World!"
}

test_intergers() {
  13e+1
  3536
  0x0FDDA24
  05353
}

test_variable() {
  a:size
  _ = a
  x: = 10;
  x = 100
  outln(x);
}

test_assignment() {
  x: = 10
  x += 100;
}

test_array() {
  my_array: = new [][]str
  *my_array = [][]str{
    []str{"Apple", "Banana"},
    []str{"Bred", "Cheese"},
  };
  outln(
    (*my_array)[0]
  )
}

test_anonymous_function() {
  my_func:() = () {
    outln("Hello World!")
  }
  my_func()
  rf: = () i32 {
    ret 90
  }()
  _ = rf
  (&() {
    outln("Anonymous Outln")
  })()
  a: = 0
  _ = a
}

test_multiple_variable() {
  a:i32 = 10;
  a, b:, _, c:bool = 100, 200, nil, false
  _ = c
  a, b = 10, 20
  a, b = b, a
  outln(a)
  outln(b)
  a, b, _ = test_multiple_return()
}

test_multiple_return() [i32, i32, bool] {
  < 5, 5, false
}

test_heap_allocation() {
  x: = new i32
  *x = 8429
  outln(x)
  outln(*x)
}

test_free_allocation() {
  x: = new *i32
  *x = new i32
  *(*x) = 90
  outln(*(*x))
  free *x
  free x
  x = nil
}

test_iter() {
  // Infinity iteration
  iter {
    break
    continue
  }

  // While iteration
  iter !false {
    break
  }

  // Foreach iteration
  iter in "Hello" {
    outln("X")
  }

  iter index:i32 in "Hello" {
    outln(index)
  }

  iter _, c:char in "Hello" {
    outln(c)
  }

  iter _, element:str in ([]str{"The", "X", "Programming", "Language"}) {
    outln(element)
  }

  iter index: in "TEST" {
    _ = index
  }
}

test_if_expressions() {
  if true {
    outln("IF")
  } else if true { outln("ELSE_IF0") } else if false {
    outln("ELSE_IF_1")
    if true == true
    { outln("ELSE_IF_1_IF"); }
    else {
      outln("ELSE");
    }
  } else {
    outln("ELSE")
  }
}

test_parameters(a i32, const b bool) { }

test_parameters_2(a, b i32, c, const d bool) { }

test_expression_as_statement() {
  (100)
  200
}

test_variadic_parameters(ln_every bool, ...values i32) {
  iter _, i: in values {
    if ln_every { outln(i) }
    else        { out(i) }
  }
}

test_variadic_parameters_2(...str) { }

test_volatile_parameters(volatile a, const volatile b, volatile const c i32) { }

test_casting() {
  (*i32)(100)
  (i32)(new i32)
  (f32)(5000)
  const ptr0: = new i32
  ptr1: = (*i32)(ptr0)
  ptr1 = nil
  bytes: = ([]byte)("Hello Bytes")
  outln(bytes)
  outln((str)(bytes))
}

test_pointer_arithmetic() {
  myarr: = []i32{10, 50, 24, -43, 63}
  const myarr_size:size = 5
  counter: = 0
  ptr: = &myarr[0]
  iter (counter += 1) <= myarr_size {
    outln(*ptr)
    ptr += 1
  }
  ret
  //! Below is just compiler test, not runtime test.
  a:*i32 = new i32
  a += 10
  a = a - 90
  a = a + (i32)(a)
  a = a - *a
}

test_assignment_expression() {
  x:i32 = 10
  outln((x*=10))
}

test_raw_string() {
  `Hello
  raw`

  `
  strings`
}

test_cxx_embed() {
  //cxx:std::wcout << L"Hello cxx embeds" << std::endl;
}

test_map() {
  map: = [i32:str]{
    0: "The",
    1: "X",
    2: "Programming",
    3: "Language"
  }
  map[4] = "Maps"
  outln(map)
  iter key:, value: in map {
    out(key)
    out(": ")
    outln(value)
  }
}

test_multiple_return_as_arguments() {
  test: = (a i32, b str, c char) {
    outln(a)
    outln(b)
    outln(c)
  }
  multiret: = () [i32, str, char] {
    < 134, "STR", 'B'
  }
  test(multiret())
}

test_multiple_return_as_multiple_return() {
  test1: = () [i32, str, char] { < 143, "STR", 'W' }
  test2: = () [i32, str, char] { < test1() }
  a:, b:, c: = test2()
  outln(a)
  outln(b)
  outln(c)
}

test_inblock_type_alias() {
  type int i32
  x:int = 10
  _ = x
}

test_inblock_block() {
  {
    outln("INBLOCK_BLOCK")
  }
}

test_deferred_calls() {
  defer () { outln("Defer 1") }()
  defer () { outln("Defer 2") }()
}

test_goto() {
  s := "Hello World"
  {
    ok: = false
    {
      if !ok {
        ok = true
        goto bla
      }
      goto test
    }
  bla:
    outln(ok)
  }
test:
  {
    outln("TEST")
    goto end
  }
  outln(s)
end:
}

test_targetted_arguments() {
  test: = (a, b, c, ...d i32) {}
  test(c=13, a=20, b=300)
  test(300, c=13, b=20, d=1,2,3,3,5,6)
  test(300, c=13, d=1,2,3,3,5,6, b=20)
  test(300, c=13, b=20, d=[]i32{1,2,3,4,5,6}...)
}

// doc:
// Entry point function of program.
main() {
  test_inline_function()
  test_intergers()
  test_string_concat();
  test_variable();
  test_assignment()
  test_array()
  test_anonymous_function()
  test_multiple_variable();
  test_heap_allocation()
  test_free_allocation()
  test_iter()
  test_if_expressions();
  test_parameters(24, false)
  test_parameters_2(24, 52, true, false)
  test_expression_as_statement()
  test_variadic_parameters(true);
  test_variadic_parameters(true, 10, 20);
  test_variadic_parameters(!false, []i32{1, 2, 3, 4, 5}...)
  test_variadic_parameters_2()
  test_variadic_parameters_2("TEST", "TEST_1")
  test_casting()
  test_pointer_arithmetic()
  test_assignment_expression()
  test_raw_string()
  test_cxx_embed()
  test_map()
  test_multiple_return_as_arguments()
  test_multiple_return_as_multiple_return()
  test_inblock_type_alias()
  test_inblock_block()
  test_deferred_calls()
  test_goto()
  test_targetted_arguments()
}
