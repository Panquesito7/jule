/*// X test codes

type TEST_TYPEDEF i32

//doc:Test for global variable.
TEST_GLOBAL: = 10;
//doc: Test for global constant variable.
const TEST_CONST: = 20
volatile const TEST_VOLATILE_CONST: = false
volatile TEST_VOLATILE: = 5

@inline
// doc: Test for inline function.
test_inline_function() { }

test_string_concat() {
  "Hello" + " " + "World!"
}

test_intergers() {
  13e+1
  3536
  0x0FDDA24
  05353
}

test_variable() {
  a:size
  x: = 10;
  x = 100
  outln(x);
}

test_assignment() {
  x: = 10
  x += 100;
}

test_array() {
  my_array: = new [][]str
  *my_array = [][]str{
    []str{"Apple", "Banana"},
    []str{"Bred", "Cheese"},
  };
  outln(
    (*my_array)[0]
  )
}

test_anonymous_function() {
  my_func:() = () {
    outln("Hello World!")
  }
  my_func()
  rf: = () i32 {
    ret 90
  }()
  () {
    outln("Anonymous Outln")
  }()
}

test_multiple_variable() {
  a:i32 = 10;
  a, b:, _, c:bool = 100, 200, nil, false
  a, b = 10, 20
  a, b = b, a
  outln(a)
  outln(b)
  a, b, _ = test_multiple_return()
}

test_multiple_return() [i32, i32, bool] {
  < 5, 5, false
}

test_heap_allocation() {
  x: = new i32
  *x = 8429
  outln(x)
  outln(*x)
}

test_free_allocation() {
  x: = new *i32
  *x = new i32
  *(*x) = 90
  outln(*(*x))
  free *x
  free x
  x = nil
}

test_iter() {
  // Infinity iteration
  iter {
    break
    continue
  }

  // While iteration
  iter !false {
    break
  }

  // Foreach iteration
  iter in "Hello" {
    outln("X")
  }

  iter index:i32 in "Hello" {
    outln(index)
  }

  iter _, run:rune in "Hello" {
    outln(run)
  }

  iter _, element:str in ([]str{"The", "X", "Programming", "Language"}) {
    outln(element)
  }

  iter index: in "TEST" { }
}

test_if_expressions() {
  if true {
    outln("IF")
  } else if true { outln("ELSE_IF0") } else if false {
    outln("ELSE_IF_1")
    if true == true
    { outln("ELSE_IF_1_IF"); }
    else {
      outln("ELSE");
    }
  } else {
    outln("ELSE")
  }
}

test_parameters(a i32, const b bool) { }

test_parameters_2(a, b i32, c, const d bool) { }

test_expression_as_statement() {
  (100)
  200
}

test_variadic_parameters(ln_every bool, ...values i32) {
  iter _, i: in values {
    if ln_every { outln(i) }
    else        { out(i) }
  }
}

test_variadic_parameters_2(...str) { }

test_volatile_parameters(volatile a, const volatile b, volatile const c i32) { }

test_casting() {
  (*i32)(100)
  (i32)(new i32)
  (f32)(5000)
  const ptr0: = new i32
  ptr1: = (*i32)(ptr0)
  bytes: = ([]byte)("Hello Bytes")
  outln(bytes)
  outln((str)(bytes))
}

test_pointer_arithmetic() {
  myarr: = []i32{10, 50, 24, -43, 63}
  const myarr_size:size = 5
  counter: = 0
  ptr: = &myarr[0]
  iter (counter += 1) <= myarr_size {
    outln(*ptr)
    ptr += 1
  }
  ret
  //! Below is just compiler test, not runtime test.
  a:*i32 = new i32
  a += 10
  a = a - 90
  a = a + (i32)(a)
  a = a - *a
}

test_assignment_expression() {
  x:i32 = 10
  outln((x*=10))
}

test_raw_string() {
  `Hello
  raw`

  `
  strings`
}

// doc:
// Entry point function of program.
main() {
  test_inline_function()
  test_intergers()
  test_string_concat();
  test_variable();
  test_assignment()
  test_array()
  test_anonymous_function()
  test_multiple_variable();
  test_heap_allocation()
  test_free_allocation()
  test_iter()
  test_if_expressions();
  test_parameters(24, false)
  test_parameters_2(24, 52, true, false)
  test_expression_as_statement()
  test_variadic_parameters(true);
  test_variadic_parameters(true, 10, 20);
  test_variadic_parameters(!false, []i32{1, 2, 3, 4, 5}...)
  test_variadic_parameters_2()
  test_variadic_parameters_2("TEST", "TEST_1")
  test_casting()
  test_pointer_arithmetic()
  test_assignment_expression()
  test_raw_string()
}
*/

main() {
  sum(4, 5)
}
