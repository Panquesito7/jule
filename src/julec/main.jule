// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// This is the main package of JuleC.

use deadcode::{eliminate_dead_code}
use env::{Opt, OptLevel, OPTIMIZATIONS, push_opt_level, is_opt_enabled}
use importer::{PlainImporter}
use obj::{IR, build_ir}
use obj::cxx

use std::fs::{FsError, OFlag, stat, open}
use std::fs::path::{join, dir}
use std::jule::{VERSION}
use std::jule::build::{
	self,
	Log,
	PATH_WD,
	PATH_STDLIB,
	DISTOS,
	DISTARCH,
	ENTRY_POINT,
	errorf,
	is_valid_cpp_ext,
}
use std::jule::lex::{is_decimal, is_ident_rune, is_letter, is_space}
use std::jule::sema::{
	ImportInfo,
	Package,
	analyze_package,
}
use std::env::{ARGS}
use std::process::{exit}
use std::runtime::{OS}

use cpp "julec.hpp"

cpp fn mkdir(path: str): bool
cpp fn rmdir(path: str)
cpp fn system(cmd: str): int

enum Compiler: str {
	NA = "",
	GCC = "gcc",
	Clang = "clang",
}

enum CompilerPath: str {
	NA = "",
	GCC = "g++",
	Clang = "clang++",
}

enum Mode {
	Compile,
	Transpile,
}

const ERROR_EXIT_CODE = 1

// Sets by COMPILER or command-line inputs
static mut COMPILER: Compiler = Compiler.NA
static mut COMPILER_PATH: CompilerPath = CompilerPath.NA

static mut OUT_DIR: str = "dist"
static mut MODE: Mode = Mode.Compile
static mut OUT_NAME: str = "ir.cpp"
static mut OUT: str = ""

const CMD_HELP = "help"
const CMD_VERSION = "version"
const CMD_TOOL = "tool"

static HELP_MAP: [...][2]str = [
	[CMD_HELP, "Show help"],
	[CMD_VERSION, "Show version"],
	[CMD_TOOL, "Tools for effective Jule"],
]

fn str_repeat(sub: str, mut n: int): str {
	if n == 0 {
		ret ""
	}

	let mut s = ""
	for n > 0; n-- {
		s += sub
	}
	ret s
}

fn print_error_message(msg: str) { outln(msg) }

fn help() {
	if ARGS.len > 2 {
		print_error_message("invalid command: " + ARGS[2])
		ret
	}

	let mut max = HELP_MAP[0][0].len
	for _, k in HELP_MAP {
		let n = k[0].len
		if n > max {
			max = n
		}
	}

	let mut s = ""
	const SPACE = 5 // Space of between command name and description.
	for i, part in HELP_MAP {
		s += part[0]
		s += str_repeat(" ", (max-part[0].len)+SPACE)
		s += part[1]
		if i+1 < HELP_MAP.len {
			s += "\n"
		}
	}
	outln(s)
}

fn version() {
	if ARGS.len > 2 {
		print_error_message("invalid command: " + ARGS[2])
		ret
	}
	out("julec version ")
	outln(VERSION)
}

fn tool_distos() {
	out("supported operating systems:\n ")
	for _, os in DISTOS {
		out(os)
		out(" ")
	}
	outln("")
}

fn tool_distarch() {
	out("supported architects:\n ")
	for _, arch in DISTARCH {
		out(arch)
		out(" ")
	}
	outln("")
}
 
fn tool() {
	if ARGS.len == 2 {
		outln(`tool commands:
 distos     Lists all supported operating systems
 distarch   Lists all supported architects`)
		ret
	} else if ARGS.len > 3 {
		print_error_message("invalid command: " + ARGS[3])
		ret
	}

	let cmd = ARGS[2]
	match cmd {
	| "distos":   tool_distos()
	| "distarch": tool_distarch()
	|:            print_error_message("Undefined command: " + cmd)
	}
}

fn process_command(): bool {
	match ARGS[1] {
	| CMD_HELP:    help()
	| CMD_VERSION: version()
	| CMD_TOOL:    tool()
	|: ret false
	}

	ret true
}

fn init() {
	// Not started with arguments.
	// Here is "2" but "os.Args" always have one element for store working directory.
	if ARGS.len < 2 {
		exit(0)
	}

	// Configure compiler to default by platform
	if OS == "windows" {
		COMPILER = Compiler.GCC
		COMPILER_PATH = CompilerPath.GCC
	} else {
		COMPILER = Compiler.Clang
		COMPILER_PATH = CompilerPath.Clang
	}

	if process_command() {
		exit(0)
	}
}

unsafe fn get_option(args: []str, mut i: *int): (arg: str, content: str) {
	for *i < args.len; *i++ {
		arg = args[*i]
		let mut j = 0
		let mut runes = ([]rune)(arg)
		let mut r = runes[j]
		if r != '-' {
			content += arg
			arg = "" // Forget argument
			continue
		}
		j++
		if j >= runes.len {
			exit_err("undefined syntax: " + arg)
		}
		r = runes[j]
		if r == '-' {
			j++
			if j >= runes.len {
				exit_err("undefined syntax: " + arg)
			}
			r = runes[j]
		}
		if !is_ident_rune(str(r)) {
			exit_err("undefined syntax: " + arg)
		}
		j++
		for j < runes.len; j++ {
			r = runes[j]
			if (
				!is_space(r) &&
				!is_letter(r) &&
				!is_decimal(byte(r)) &&
				r != '_' &&
				r != '-'
			) {
				exit_err("undefined syntax: " + str(runes[j:]))
			}
		}
		break
	}
	ret
}

unsafe fn get_option_value(args: []str, mut i: *int): str {
	*i++ // Argument value is the next argument
	if *i < args.len {
		let arg = args[*i]
		ret arg
	}
	ret ""
}

unsafe fn parse_out_option(args: []str, mut i: *int) {
	let value = get_option_value(args, i)
	if value == "" {
		exit_err("missing option value: -o --out")
	}
	OUT = value
}

unsafe fn parse_opt_option(args: []str, mut i: *int) {
	let value = get_option_value(args, i)
	if value == "" {
		exit_err("missing option value: --opt")
	}

	match value {
	| "L0": push_opt_level(OptLevel.L0)
	| "L1": push_opt_level(OptLevel.L1)
	|:      exit_err("invalid optimization level: " + value)
	}
}

fn check_target_arch(arch: str) {
	for _, distarch in DISTARCH {
		if arch == str(distarch) {
			ret
		}
	}

	exit_err("unsupported/undefined architecture: " + arch)
}

fn check_target_os(os: str) {
	for _, distos in DISTOS {
		if os == str(distos) {
			ret
		}
	}

	exit_err("unsupported/undefined operating system: " + os)
}

unsafe fn parse_target_option(args: []str, mut i: *int) {
	let value = get_option_value(args, i)
	if value == "" {
		exit_err("missing option value: --target")
	}

	let parts = value.split("-", -1)
	if parts.len != 2 {
		exit_err("undefined platform target format: " + value)
	}

	let (os, arch) = parts[0], parts[1]

	if os != "native" {
		check_target_os(os)
		std::jule::build::OS = os
	}

	if arch != "native" {
		check_target_arch(arch)
		std::jule::build::ARCH = arch
	}
}

unsafe fn parse_compiler_option(args: []str, mut i: *int) {
	let value = get_option_value(args, i)
	match value {
	| "":
		exit_err("missing option value: --compiler")

	| str(Compiler.Clang):
		COMPILER = Compiler.Clang
		COMPILER_PATH = CompilerPath.Clang

	| str(Compiler.GCC):
		COMPILER = Compiler.GCC
		COMPILER_PATH = CompilerPath.GCC

	|:
		exit_err("invalid option value for --compiler: " + value)
	}
}

fn parse_options(args: []str): str {
	let mut cmd = ""
	let mut i = 1 // Start 1 because the index 0 is a path, not an command-line argument
	for i < args.len; i++ {
		let (arg, content) = unsafe { get_option(args, &i) }
		cmd += content
		match arg {
		| "":

		| "-o" | "--out":
			unsafe { parse_out_option(args, &i) }

		| "-t" | "--transpile":
			MODE = Mode.Transpile

		| "-c" | "--compile":
			MODE = Mode.Compile

		| "--compiler":
			unsafe { parse_compiler_option(args, &i) }

		| str(Opt.Copy):
			OPTIMIZATIONS = append(OPTIMIZATIONS, Opt.Copy)

		| str(Opt.DeadCode):
			OPTIMIZATIONS = append(OPTIMIZATIONS, Opt.DeadCode)

		| "--opt":
			unsafe { parse_opt_option(args, &i) }

		| "--target":
			unsafe { parse_target_option(args, &i) }

		|:
			exit_err("undefined option: " + arg)
		}
	}
	cmd = cmd.trim(" \t\r\n\v")
	ret cmd
}

fn write_output(path: str, content: str) {
	let dir = dir(path)

	let (_, mut err) = stat(dir)
	if err != FsError.Ok {
		let ok = cpp.mkdir(dir)
		if !ok {
			exit_err("a problem occurs when code generation")
		}
	}

	let (mut f, err) = open(path, OFlag.Rdwr|OFlag.Create|OFlag.Trunc, 0666)
	if err != FsError.Ok {
		exit_err("a problem occurs when code generation")
	}

	_, err = f.write(([]byte)(content))
	if err != FsError.Ok {
		exit_err("a problem occurs when code generation")
	}
	_ = f.close()
}

fn clear_objects() {
	cpp.rmdir(OUT_DIR)
}

fn compile_ir(compiler: str, compiler_cmd: str) {
	let status = cpp.system(compiler + " " + compiler_cmd)
	if status != 0 {
		out("external compiler failed with status code: ");
		outln(status)
		exit_err("")
	}

	clear_objects()
}

fn do_spell(obj: str, compiler: str, compiler_cmd: str) {
	let path = get_compile_path()
	write_output(path, obj)
	match MODE {
	| Mode.Compile:
		compile_ir(compiler, compiler_cmd)
	}
}

fn exit_err(msg: str) {
	outln(msg)
	exit(ERROR_EXIT_CODE)
}

fn check_mode() {
	if MODE != Mode.Transpile && MODE != Mode.Compile {
		outln(errorf("invalid_value_for_key", MODE, "mode"))
		exit_err("")
	}
}

fn check_compiler() {
	if COMPILER != Compiler.GCC && COMPILER != Compiler.Clang {
		outln(errorf("invalid_value_for_key", COMPILER, "compiler"))
		exit_err("")
	}
}

fn set() {
	check_mode()
	check_compiler()
}

// print_logs prints logs and returns true
// if logs has error, false if not.
fn print_logs(logs: []Log) {
	let mut s = ""
	for _, l in logs {
		s += l.to_str() + "\n"
	}
	out(s)
}

fn is_cpp_source_file(path: str): bool {
	let offset = path.rfind(".")
	if offset == -1 {
		ret false
	}
	ret is_valid_cpp_ext(path[offset:])
}

fn gen_compile_cmd(source_path: str, ir: &IR): (str, str) {
	let compiler = str(COMPILER_PATH)

	const ZERO_LEVEL_OPTIMIZATION = "-O0"
	const DISABLE_ALL_WARNINGS_CLANG = "-Wno-everything"
	const DISABLE_ALL_WARNINGS_GCC = "-w"
	const SET_STD = "--std=c++14"

	let mut cmd = ZERO_LEVEL_OPTIMIZATION + " "

	match COMPILER {
	| Compiler.GCC:
		cmd += DISABLE_ALL_WARNINGS_GCC + " "

	| Compiler.Clang:
		cmd += DISABLE_ALL_WARNINGS_CLANG + " "
	}
	cmd += SET_STD + " "

	// Push passes.
	for _, pass in ir.passes {
		cmd += pass + " "
	}

	// Push linked source files.
	for _, u in ir.used {
		if u.cpp_linked && is_cpp_source_file(u.path) {
			cmd += u.path + " "
		}
	}

	if OUT != "" {
		cmd += "-o " + OUT + " "
	}
	cmd += source_path

	ret compiler, cmd
}

fn get_compile_path(): str {
	let mut path = join(PATH_WD, OUT_DIR)
	path = join(path, OUT_NAME)
	ret path
}

fn apply_target_independent_optimizations(mut ir: &IR) {
	if is_opt_enabled(Opt.DeadCode) {
		eliminate_dead_code(ir)
	}
}

fn main() {
	let path = parse_options(ARGS)
	if path == "" {
		exit_err(errorf("missing_compile_path"))
	}

	// Check standard library.
	let (inf, err) = stat(PATH_STDLIB)
	if err != FsError.Ok || !inf.is_dir() {
		exit_err(errorf("stdlib_not_exist"))
	}

	set()

	let (mut ir, logs) = build_ir(path)

	if !real(ir) && logs == nil {
		exit_err(errorf("no_file_in_entry_package", path))
	}

	if logs != nil {
		print_logs(logs)
		exit_err("")
	}

	const CPP_LINKED = false
	let f = ir.main.find_fn(ENTRY_POINT, CPP_LINKED)
	if !real(f) {
		exit_err(errorf("no_entry_point"))
	}

	apply_target_independent_optimizations(ir)

	let (compiler, compiler_cmd) = gen_compile_cmd(get_compile_path(), ir)

	let mut obj = obj::cxx::gen(ir)
	unsafe { obj::cxx::append_standard(&obj, compiler, compiler_cmd) }

	do_spell(obj, compiler, compiler_cmd)
}
