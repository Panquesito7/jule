// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// This is the main package of JuleC.

use std::jule::{VERSION}
use std::jule::build::{DISTOS, DISTARCH}
use std::env::{ARGS}
use std::process::{exit}
use std::runtime::{OS}

use cpp "julec.hpp"

cpp fn mkdir(path: str): bool
cpp fn rmdir(path: str)
cpp fn system(cmd: str): int

enum Compiler: str {
	NA = "",
	GCC = "gcc",
	Clang = "clang",
}

enum CompilerPath: str {
	NA = "",
	GCC = "g++",
	Clang = "clang++",
}

enum Mode {
	Compile,
	Transpile,
}

const ERROR_EXIT_CODE = 1

// Sets by COMPILER or command-line inputs
static mut COMPILER: Compiler = Compiler.NA
static mut COMPILER_PATH: CompilerPath = CompilerPath.NA

static mut OUT_DIR: str = "dist"
static mut MODE: Mode = Mode.Compile
static mut OUT_NAME: str = "ir.cpp"
static mut OUT: str = ""

const CMD_HELP = "help"
const CMD_VERSION = "version"
const CMD_TOOL = "tool"

static HELP_MAP: [...][2]str = [
	[CMD_HELP, "Show help"],
	[CMD_VERSION, "Show version"],
	[CMD_TOOL, "Tools for effective Jule"],
]

fn str_repeat(sub: str, mut n: int): str {
	if n == 0 {
		ret ""
	}

	let mut s = ""
	for n > 0; n-- {
		s += sub
	}
	ret s
}

fn print_error_message(msg: str) { outln(msg) }

fn help() {
	if ARGS.len > 2 {
		print_error_message("invalid command: " + ARGS[2])
		ret
	}

	let mut max = HELP_MAP[0][0].len
	for _, k in HELP_MAP {
		let n = k[0].len
		if n > max {
			max = n
		}
	}

	let mut s = ""
	const SPACE = 5 // Space of between command name and description.
	for i, part in HELP_MAP {
		s += part[0]
		s += str_repeat(" ", (max-part[0].len)+SPACE)
		s += part[1]
		if i+1 < HELP_MAP.len {
			s += "\n"
		}
	}
	outln(s)
}

fn version() {
	if ARGS.len > 2 {
		print_error_message("invalid command: " + ARGS[2])
		ret
	}
	out("julec version ")
	outln(VERSION)
}

fn tool_distos() {
	out("supported operating systems:\n ")
	for _, os in DISTOS {
		out(os)
		out(" ")
	}
	outln("")
}

fn tool_distarch() {
	out("supported architects:\n ")
	for _, arch in DISTARCH {
		out(arch)
		out(" ")
	}
	outln("")
}
 
fn tool() {
	if ARGS.len == 2 {
		outln(`tool commands:
 distos     Lists all supported operating systems
 distarch   Lists all supported architects`)
		ret
	} else if ARGS.len > 3 {
		print_error_message("invalid command: " + ARGS[3])
		ret
	}

	let cmd = ARGS[2]
	match cmd {
	| "distos":   tool_distos()
	| "distarch": tool_distarch()
	|:            print_error_message("Undefined command: " + cmd)
	}
}

fn process_command(): bool {
	match ARGS[1] {
	| CMD_HELP:    help()
	| CMD_VERSION: version()
	| CMD_TOOL:    tool()
	|: ret false
	}

	ret true
}

fn init() {
	// Configure compiler to default by platform
	if OS == "windows" {
		COMPILER = Compiler.GCC
		COMPILER_PATH = CompilerPath.GCC
	} else {
		COMPILER = Compiler.Clang
		COMPILER_PATH = CompilerPath.Clang
	}
}

fn exit_err(msg: str) {
	outln(msg)
	exit(ERROR_EXIT_CODE)
}

fn main() {
	// Not started with arguments.
	// Here is "2" but "os.Args" always have one element for store working directory.
	if ARGS.len < 2 {
		exit(0)
	}

	if process_command() {
		ret
	}

	compile_command()
}
