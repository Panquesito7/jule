// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use obj::{IR}

use std::jule::sema::{
	Package,
	Fn,
	Struct,
	Var,
	ReferenceStack,
	Trait,
}
use std::vector::{Vector}

// Stores all dead definitions.
static mut deads: []any = nil

// Stores currently checking definitions.
static mut checking: []any = nil

// Currently checking reference.
static mut current: any = nil

// Reports whether the reference type of T exist in arr.
fn is_exist[T](arr: []any, t: &T): bool {
	for _, ref in arr {
		match type ref {
		| &T:
			if &(&T)(ref) == &t {
				ret true
			}
		}
	}
	ret false
}

// Reports whether ref is exist in refs.
fn is_exist_ref(mut refs: []any, ref: any): bool {
	match type ref {
	| &Fn:     ret is_exist[Fn](refs, (&Fn)(ref))
	| &Var:    ret is_exist[Var](refs, (&Var)(ref))
	| &Struct: ret is_exist[Struct](refs, (&Struct)(ref))
	| &Trait:  ret is_exist[Trait](refs, (&Trait)(ref))
	|:         ret false
	}
}

// Reports whether reference in dead.
fn is_dead(mut ref: any): (dead: bool) {
	if is_exist_ref(deads, ref) {
		// Cycle, also already checked and marked as dead.
		ret true
	}
	if is_exist_ref(checking, ref) {
		// Cycle, also already checked and should be marked alive.
		ret false
	}

	let mut old = current
	current = ref
	let len = checking.len
	checking = append(checking, ref)
	defer {
		current = old
		drop_ref(checking, len)
		if dead {
			deads = append(deads, ref)
		}
	}

	match type ref {
	| &Fn:     ret is_fn_dead((&Fn)(ref))
	| &Var:    ret is_var_dead((&Var)(ref))
	| &Struct: ret is_struct_dead((&Struct)(ref))
	| &Trait:  ret is_trait_dead((&Trait)(ref))
	|:         ret false
	}
}

// Remove reference from refs by pos.
fn drop_ref(mut &refs: []any, pos: int) {
	// Remove position, and following references.
	// This is safe.
	// References dropped after processed, so following
	// references should be already processed.
	refs = refs[:pos]

	/*
	if pos == (*refs).len {
		ret
	}
	*refs = append((*refs)[:pos], (*refs)[pos+1:]...)*/
}

fn is_all_references_are_dead[T](mut references: &ReferenceStack): bool {
	let mut i = 0
	for i < references.len(); i++ {
		let mut ref = references.at(i)
		match type current {
		| &T:
			match type ref {
			| &T:
				if &(&T)(current) == &(&T)(ref) {
					continue
				}
			}
		}
		if !is_dead(ref) {
			ret false
		}
	}
	ret true
}

fn is_fn_dead(mut f: &Fn): bool {
	if !f.global ||
		f.cpp_linked ||
		f.is_entry_point() ||
		f.is_init() ||
		f.is_anon() {
		ret false
	}

	// Genericed functions has instances
	// if only really referred to them.
	if f.generics.len > 0 {
		ret f.instances.len == 0
	}

	ret is_all_references_are_dead[Fn](f.references)
}

fn is_var_dead(mut v: &Var): bool {
	if v.constant {
		ret true
	}

	if v.cpp_linked {
		ret false
	}

	ret is_all_references_are_dead[Var](v.references)
}

fn is_struct_dead(mut s: &Struct): bool {
	if s.cpp_linked {
		ret false
	}

	// Genericed functions has instances
	// if only really referred to them.
	if s.generics.len > 0 {
		ret s.instances.len == 0
	}

	ret is_all_references_are_dead[Struct](s.references)
}

fn is_trait_dead(mut t: &Trait): bool {
	for (_, mut imp) in t.implemented {
		if !is_struct_dead(imp) {
			ret false
		}
	}
	ret true
}

// Eliminates dead functions.
// If functions is alive, eliminates unreachable codes, and etc for scope.
fn eliminate_dead_functions(mut &funcs: Vector[&Fn]) {
	let mut i = 0
	for i < funcs.len() {
		let mut f = funcs.at(i)
		if is_fn_dead(f) {
			funcs.remove_range(i, 1)
		} else {
			for (_, mut ins) in f.instances {
				eliminate_dead_code_of_scope(ins.scope)
			}
			i++
		}
	}
}

fn eliminate_dead_globals(mut pkg: &Package) {
	for (_, mut f) in pkg.files {
		let mut i = 0
		for i < f.vars.len() {
			if is_var_dead(f.vars.at(i)) {
				f.vars.remove_range(i, 1)
			} else {
				i++
			}
		}
	}
}

fn eliminate_dead_functions_package(mut pkg: &Package) {
	for (_, mut f) in pkg.files {
		eliminate_dead_functions(f.funcs)
	}
}

fn eliminate_dead_structs(mut pkg: &Package) {
	for (_, mut f) in pkg.files {
		let mut i = 0
		for i < f.structs.len() {
			let mut s = f.structs.at(i)
			if is_struct_dead(s) {
				f.structs.remove_range(i, 1)
			} else {
				// Not removes trait-implemented functions.
				// This is safe.
				// Because methods marked as not-global and
				// not-global functions are not removed.
				eliminate_dead_functions(s.methods)
				i++
			}
		}
	}
}

fn eliminate_dead_traits(mut pkg: &Package) {
	for (_, mut f) in pkg.files {
		let mut i = 0
		for i < f.traits.len() {
			if is_trait_dead(f.traits.at(i)) {
				f.traits.remove_range(i, 1)
			} else {
				i++
			}
		}
	}
}

fn eliminate_dead_code_package(mut pkg: &Package) {
	eliminate_dead_globals(pkg)
	eliminate_dead_functions_package(pkg)
	eliminate_dead_structs(pkg)
	eliminate_dead_traits(pkg)
}

pub fn eliminate_dead_code(mut ir: &IR) {
	for (_, mut u) in ir.used {
		if !u.cpp_linked {
			eliminate_dead_code_package(u.package)
		}
	}
	eliminate_dead_code_package(ir.main)

	// Clear memory.
	deads = nil
	checking = nil
	current = nil
}
