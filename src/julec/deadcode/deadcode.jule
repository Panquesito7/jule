// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use obj::{IR}

use std::jule::sema::{
	Package,
	Fn,
	Struct,
	Var,
	ReferenceStack,
	Trait,
}
use std::vector::{Vector}

// Stores all dead definitions.
let mut deads: []any = nil

fn is_exist[T](arr: []any, t: &T): bool {
	for _, ref in arr {
		match type ref {
		| &T:
			if &(&T)(ref) == &t {
				ret true
			}
		}
	}
	ret false
}

fn is_dead_ref(ref: any): bool {
	match type ref {
	| &Fn:     ret is_exist[Fn](deads, (&Fn)(ref))
	| &Var:    ret is_exist[Var](deads, (&Var)(ref))
	| &Struct: ret is_exist[Struct](deads, (&Struct)(ref))
	| &Trait:  ret is_exist[Trait](deads, (&Trait)(ref))
	|:         ret false
	}
}

fn is_dead(mut ref: any): (dead: bool) {
	if is_dead_ref(ref) {
		// Cycle, also already checked and marked as dead.
		ret true
	}

	let len = deads.len
	deads = append(deads, ref)
	defer {
		if !dead {
			drop_deads(len)
		}
	}

	match type ref {
	| &Fn:     ret is_fn_dead((&Fn)(ref))
	| &Var:    ret is_var_dead((&Var)(ref))
	| &Struct: ret is_struct_dead((&Struct)(ref))
	| &Trait:  ret is_trait_dead((&Trait)(ref))
	|:         ret false
	}
}

fn drop_deads(pos: int) {
	if pos == deads.len {
		deads = deads[:pos]
		ret
	}
	deads = append(deads[:pos], deads[pos+1:]...)
}

fn is_all_references_are_dead(mut references: &ReferenceStack): bool {
	let mut i = 0
	for i < references.len(); i++ {
		let mut ref = references.at(i)
		if !is_dead(ref) {
			ret false
		}
	}
	ret true
}

fn is_fn_dead(mut f: &Fn): bool {
	if !f.global || f.cpp_linked || f.is_entry_point() || f.is_init() || f.is_anon() {
		ret false
	}

	// Genericed functions has instances
	// if only really referred to them.
	if f.generics.len > 0 {
		ret f.instances.len == 0
	}

	ret is_all_references_are_dead(f.references)
}

fn is_var_dead(mut v: &Var): bool {
	if v.constant {
		ret true
	}

	if v.cpp_linked {
		ret false
	}

	ret is_all_references_are_dead(v.references)
}

fn is_struct_dead(mut s: &Struct): bool {
	if s.cpp_linked {
		ret false
	}

	// Genericed functions has instances
	// if only really referred to them.
	if s.generics.len > 0 {
		ret s.instances.len == 0
	}

	ret is_all_references_are_dead(s.references)
}

fn is_trait_dead(mut t: &Trait): bool {
	for (_, mut imp) in t.implemented {
		if !is_struct_dead(imp) {
			ret false
		}
	}
	ret true
}

unsafe fn eliminate_dead_functions(mut funcs: *Vector[&Fn]) {
	let mut i = 0
	for i < funcs.len() {
		let mut f = funcs.at(i)
		if is_fn_dead(f) {
			funcs.remove_range(i, 1)
		} else {
			for (_, mut ins) in f.instances {
				eliminate_dead_code_of_scope(ins.scope)
			}
			i++
		}
	}
}

fn eliminate_dead_globals(mut pkg: &Package) {
	for (_, mut f) in pkg.files {
		let mut i = 0
		for i < f.vars.len() {
			if is_var_dead(f.vars.at(i)) {
				f.vars.remove_range(i, 1)
			} else {
				i++
			}
		}
	}
}

fn eliminate_dead_functions_package(mut pkg: &Package) {
	for (_, mut f) in pkg.files {
		unsafe { eliminate_dead_functions(&f.funcs) }
	}
}

fn eliminate_dead_structs(mut pkg: &Package) {
	for (_, mut f) in pkg.files {
		let mut i = 0
		for i < f.structs.len() {
			let mut s = f.structs.at(i)
			if is_struct_dead(s) {
				f.structs.remove_range(i, 1)
			} else {
				// Not removes trait-implemented functions.
				// This is safe.
				// Because methods marked as not-global and
				// not-global functions are not removed.
				unsafe { eliminate_dead_functions(&s.methods) }
				i++
			}
		}
	}
}

fn eliminate_dead_traits(mut pkg: &Package) {
	for (_, mut f) in pkg.files {
		let mut i = 0
		for i < f.traits.len() {
			if is_trait_dead(f.traits.at(i)) {
				f.traits.remove_range(i, 1)
			} else {
				i++
			}
		}
	}
}

fn eliminate_dead_code_package(mut pkg: &Package) {
	eliminate_dead_globals(pkg)
	eliminate_dead_functions_package(pkg)
	eliminate_dead_structs(pkg)
	eliminate_dead_traits(pkg)
}

pub fn eliminate_dead_code(mut ir: &IR) {
	for (_, mut u) in ir.used {
		if !u.cpp_linked {
			eliminate_dead_code_package(u.package)
		}
	}
	eliminate_dead_code_package(ir.main)

	deads = nil // Clear memory.
}
