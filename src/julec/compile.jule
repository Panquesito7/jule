// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

/*

Compiler Reference

(1) All definitions should be listed when obtained after semantic analysis.
    This sorting should be done by dependency. Jule provides an orderer
    algorithm for this. After semantic analysis, all definitions must be
    sorted and ready. If this sorted data is needed in the next stages,
    everything is considered to be in order. Assumed as already ordered.

*/

use deadcode
use env::{self, Opt, OptLevel, OPTIMIZATIONS, push_opt_level, is_opt_enabled}
use importer
use obj
use cxx for obj::cxx

use std::env
use std::fs::{FsError, OFlag, stat, open, create_dir, remove_file, remove_dir}
use std::fs::path::{join, dir}
use integrated for std::jule::integrated
use std::jule::lex::{is_decimal, is_ident_rune, is_letter, is_space}
use std::jule::sema::{
    ImportInfo,
    Package,
    SemaFlag,
    analyze_package,
}
use std::jule::build::{
    self,
    LogMsg,
    Log,
    PATH_WD,
    PATH_STDLIB,
    DISTOS,
    DISTARCH,
    ENTRY_POINT,
    INIT_FN,
    logf,
    is_valid_cpp_ext,
}

cpp unsafe fn system(cmd: *integrated::Char): int

// Officially supported backend-compilers.
enum Compiler: str {
    NA = "",
    GCC = "gcc",
    Clang = "clang",
}

// Paths of officially supported backend-compilers.
enum CompilerPath: str {
    NA = "",
    GCC = "g++",
    Clang = "clang++",
}

// Compiler mode.
enum Mode {
    Compile,
    Transpile,
}

// Sets by COMPILER or command-line inputs.
static mut COMPILER: Compiler = Compiler.NA
static mut COMPILER_PATH: CompilerPath = CompilerPath.NA

static mut OUT_DIR: str = "dist"
static mut MODE: Mode = Mode.Compile
static mut OUT_NAME: str = "ir.cpp"
static mut OUT: str = ""
static mut CPP_STD: str = "c++17" // Default C++ standard

static mut SEMA_FLAGS: SemaFlag = SemaFlag.Default

fn system(cmd: str): int {
    ret unsafe { cpp.system((*integrated::Char)(&cmd[0])) }
}

fn get_option(&args: []str, mut &i: int): (arg: str, content: str) {
    for i < args.len; i++ {
        arg = args[i]
        let mut j = 0
        let mut runes = ([]rune)(arg)
        let mut r = runes[j]
        if r != '-' {
            content += arg
            arg = "" // Forget argument
            continue
        }
        j++
        if j >= runes.len {
            exit_err("undefined syntax: " + arg)
        }
        r = runes[j]
        if r == '-' {
            j++
            if j >= runes.len {
                exit_err("undefined syntax: " + arg)
            }
            r = runes[j]
        }
        if !is_ident_rune(str(r)) {
            exit_err("undefined syntax: " + arg)
        }
        j++
        for j < runes.len; j++ {
            r = runes[j]
            if (
                !is_space(r) &&
                !is_letter(r) &&
                !is_decimal(byte(r)) &&
                r != '_' &&
                r != '-'
            ) {
                exit_err("undefined syntax: " + str(runes[j:]))
            }
        }
        break
    }
    ret
}

fn get_option_value(&args: []str, mut &i: int): str {
    i++ // Argument value is the next argument
    if i < args.len {
        let arg = args[i]
        ret arg
    }
    ret ""
}

fn parse_out_option(&args: []str, mut &i: int) {
    let value = get_option_value(args, i)
    if value == "" {
        exit_err("missing option value: -o --out")
    }
    OUT = value
}

fn parse_opt_option(&args: []str, mut &i: int) {
    let value = get_option_value(args, i)
    if value == "" {
        exit_err("missing option value: --opt")
    }

    match value {
    | "L0": push_opt_level(OptLevel.L0)
    | "L1": push_opt_level(OptLevel.L1)
    |:      exit_err("invalid optimization level: " + value)
    }
}

fn check_target_arch(arch: str) {
    for _, distarch in DISTARCH {
        if arch == str(distarch) {
            ret
        }
    }

    exit_err("unsupported/undefined architecture: " + arch)
}

fn check_target_os(os: str) {
    for _, distos in DISTOS {
        if os == str(distos) {
            ret
        }
    }

    exit_err("unsupported/undefined operating system: " + os)
}

fn parse_target_option(&args: []str, mut &i: int) {
    let value = get_option_value(args, i)
    if value == "" {
        exit_err("missing option value: --target")
    }

    let parts = value.split("-", -1)
    if parts.len != 2 {
        exit_err("undefined platform target format: " + value)
    }

    let (os, arch) = parts[0], parts[1]

    if os != "native" {
        check_target_os(os)
        env::OS = os
    }

    if arch != "native" {
        check_target_arch(arch)
        env::ARCH = arch
    }
}

fn parse_compiler_option(&args: []str, mut &i: int) {
    let value = get_option_value(args, i)
    match value {
    | "":
        exit_err("missing option value: --compiler")

    | str(Compiler.Clang):
        COMPILER = Compiler.Clang
        COMPILER_PATH = CompilerPath.Clang

    | str(Compiler.GCC):
        COMPILER = Compiler.GCC
        COMPILER_PATH = CompilerPath.GCC

    |:
        exit_err("invalid option value for --compiler: " + value)
    }
}

fn parse_options(&args: []str): str {
    let mut cmd = ""

    // Start at 1 because the index 0 is a path,
    // not an command-line argument
    let mut i = 1
    for i < args.len; i++ {
        let (arg, content) = get_option(args, i)
        cmd += content
        match arg {
        | "":

        | "-o" | "--out":
            parse_out_option(args, i)

        | "-t" | "--transpile":
            MODE = Mode.Transpile

        | "-c" | "--compile":
            MODE = Mode.Compile

        | "--compiler":
            parse_compiler_option(args, i)

        | "--opt":
            parse_opt_option(args, i)

        | "--target":
            parse_target_option(args, i)

        | "--shadowing":
            SEMA_FLAGS |= SemaFlag.Shadowing

        | str(Opt.Copy):     OPTIMIZATIONS = append(OPTIMIZATIONS, Opt.Copy)
        | str(Opt.DeadCode): OPTIMIZATIONS = append(OPTIMIZATIONS, Opt.DeadCode)
        | str(Opt.Append):   OPTIMIZATIONS = append(OPTIMIZATIONS, Opt.Append)
        | str(Opt.Math):     OPTIMIZATIONS = append(OPTIMIZATIONS, Opt.Math)
        | str(Opt.Access):   OPTIMIZATIONS = append(OPTIMIZATIONS, Opt.Access)
        | str(Opt.Inline):   OPTIMIZATIONS = append(OPTIMIZATIONS, Opt.Inline)

        |:
            exit_err("undefined option: " + arg)
        }
    }
    cmd = cmd.trim(" \t\r\n\v")
    ret cmd
}

fn write_output(path: str, content: str) {
    let dir = dir(path)

    let (_, mut err) = stat(dir)
    if err != FsError.Ok {
        err = create_dir(dir)
        if err != FsError.Ok {
            exit_err("a problem occurs when code generation")
        }
    }

    let (mut f, err) = open(path, OFlag.Rdwr|OFlag.Create|OFlag.Trunc, 0666)
    if err != FsError.Ok {
        exit_err("a problem occurs when code generation")
    }

    _, err = f.write(([]byte)(content))
    if err != FsError.Ok {
        exit_err("a problem occurs when code generation")
    }
    _ = f.close()
}

// Remove generated objects for compilation.
fn clear_objects() {
    if remove_file(get_compile_path()) != FsError.Ok {
        outln("a problem occurs when object cleaning")
        ret
    }

    // All created objects are cleaned.
    // So, deletes directory if empty after cleaned all objects,
    // if not, leaves the directory.
    _ = remove_dir(OUT_DIR)
}

// Compie generated IR.
fn compile_ir(compiler: str, compiler_cmd: str) {
    let status = system(compiler + " " + compiler_cmd)
    if status != 0 {
        out("external compiler failed with status code: ");
        outln(status)
        exit_err("")
    }

    clear_objects()
}

// Compile.
fn do_spell(obj: str, compiler: str, compiler_cmd: str) {
    let path = get_compile_path()
    write_output(path, obj)
    match MODE {
    | Mode.Compile:
        compile_ir(compiler, compiler_cmd)
    }
}

fn check_mode() {
    if MODE != Mode.Transpile && MODE != Mode.Compile {
        outln(logf(LogMsg.InvalidValueForKey, MODE, "mode"))
        exit_err("")
    }
}

fn check_compiler() {
    if COMPILER != Compiler.GCC && COMPILER != Compiler.Clang {
        outln(logf(LogMsg.InvalidValueForKey, COMPILER, "compiler"))
        exit_err("")
    }
}

fn set() {
    check_mode()
    check_compiler()

    // Initialize flags for directive eval.
    importer::init_flags()
}

fn is_cpp_source_file(path: str): bool {
    let offset = path.rfind(".")
    if offset == -1 {
        ret false
    }
    ret is_valid_cpp_ext(path[offset:])
}

// Generate compile command for backend-compiler.
fn gen_compile_cmd(source_path: str, &ir: &obj::IR): (str, str) {
    let compiler = str(COMPILER_PATH)

    const ZERO_LEVEL_OPTIMIZATION = "-O0"
    const DISABLE_ALL_WARNINGS_CLANG = "-Wno-everything"
    const DISABLE_ALL_WARNINGS_GCC = "-w"
    let SET_STD = "--std=" + CPP_STD

    let mut cmd = ZERO_LEVEL_OPTIMIZATION + " "

    match COMPILER {
    | Compiler.GCC:
        cmd += DISABLE_ALL_WARNINGS_GCC + " "

    | Compiler.Clang:
        cmd += DISABLE_ALL_WARNINGS_CLANG + " "
    }
    cmd += SET_STD + " "

    // Push passes.
    for _, pass in ir.passes {
        cmd += pass + " "
    }

    // Push linked source files.
    for _, u in ir.used {
        if u.cpp_linked && is_cpp_source_file(u.path) {
            cmd += u.path + " "
        }
    }

    if OUT != "" {
        cmd += "-o " + OUT + " "
    }
    cmd += source_path

    ret compiler, cmd
}

fn get_compile_path(): str {
    // let mut path = join(PATH_WD, OUT_DIR)
    // path = join(path, OUT_NAME)
    // ret path

    // Return command-line argument form
    // instead of absolute path.
    ret join(OUT_DIR, OUT_NAME)
}

fn apply_target_independent_optimizations(mut &ir: &obj::IR) {
    if is_opt_enabled(Opt.DeadCode) {
        deadcode::eliminate(ir)
    }
}

// Process compile command by "ARGS" global.
fn compile_command(&args: []str) {
    let path = parse_options(args)
    if path == "" {
        exit_err(logf(LogMsg.MissingCompilePath))
    }

    // Check standard library.
    let (inf, err) = stat(PATH_STDLIB)
    if err != FsError.Ok || !inf.is_dir() {
        exit_err(logf(LogMsg.StdlibNotExist))
    }

    set()

    let (mut ir, logs) = obj::IR.build(path, SEMA_FLAGS)

    if !real(ir) && logs == nil {
        exit_err(logf(LogMsg.NoFileInEntryPackage, path))
    }

    if logs != nil {
        Logger.print_logs(logs)
        exit_err("")
    }

    const CPP_LINKED = false
    let mut f = ir.main.find_fn(ENTRY_POINT, CPP_LINKED)
    if !real(f) {
        exit_err(logf(LogMsg.NoEntryPoint))
    }
    f.statically = true // Used

    f = ir.main.find_fn(INIT_FN, CPP_LINKED)
    if real(f) {
        f.statically = true // Used
    }

    apply_target_independent_optimizations(ir)

    // See compiler reference (1)
    ir.order()

    let (compiler, compiler_cmd) = gen_compile_cmd(get_compile_path(), ir)

    let mut obj = cxx::gen(ir)
    cxx::append_standard(obj, compiler, compiler_cmd)

    do_spell(obj, compiler, compiler_cmd)
}
